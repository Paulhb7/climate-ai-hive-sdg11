"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBinLabelArray = exports.getBinLabel = exports.getMapLayerColors = exports.interpolateColors = exports.rgbToHex = void 0;
const mapConsts_1 = require("../consts/mapConsts");
const unit_1 = require("./unit");
const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
exports.rgbToHex = rgbToHex;
const interpolateColors = (startColor, endColor) => {
    const newColors = [];
    if (startColor && endColor) {
        newColors.push((0, exports.rgbToHex)(startColor.r, startColor.g, startColor.b));
        for (let i = 0; i < 4; i++) {
            const red = Math.round((endColor.r - startColor.r) * (0.2 * (i + 1)) + startColor.r);
            const green = Math.round((endColor.g - startColor.g) * (0.2 * (i + 1)) + startColor.g);
            const blue = Math.round((endColor.b - startColor.b) * (0.2 * (i + 1)) + startColor.b);
            newColors.push((0, exports.rgbToHex)(red, green, blue));
        }
        newColors.push((0, exports.rgbToHex)(endColor.r, endColor.g, endColor.b));
    }
    return newColors;
};
exports.interpolateColors = interpolateColors;
const getDataAttribute = (degrees, percentileValue) => {
    if (degrees === 0.5) {
        return `data_baseline_${percentileValue}`;
    }
    else {
        return `data_${degrees.toString().replace(".", "_")}c_${percentileValue}`;
    }
};
const getMapLayerColors = (colors, bins, degrees, percentileValue = "mid") => {
    const dataAttribute = getDataAttribute(degrees, percentileValue);
    const startIndex = 5;
    const additionalBins = colors
        .slice(startIndex)
        .map((_, index) => [bins[startIndex + index - 1], colors[startIndex + index]]);
    return [
        "step",
        ["get", dataAttribute],
        // color the areas with error values the same as the ocean color
        "#f5f5f5",
        mapConsts_1.ERROR_VALUE + 1,
        "#e6e6e6",
        mapConsts_1.BARREN_LAND_VALUE + 1,
        colors[0],
        bins[0],
        colors[1],
        bins[1],
        colors[2],
        bins[2],
        colors[3],
        bins[3],
        colors[4],
        ...additionalBins.flat(),
    ];
};
exports.getMapLayerColors = getMapLayerColors;
function getBinLabel(bins, index, unit, minValue, maxValue, step, tempUnit, isDiff = false, isFrequent = false, precipitationUnit, isPrecipitationMap) {
    const isTempMap = unit.toLowerCase().includes("temp");
    let finalBins = bins;
    let finalMinValue = minValue;
    let finalMaxValue = maxValue;
    if (isTempMap && tempUnit === "Â°F") {
        finalBins = (0, unit_1.convertCToF)(bins);
        finalMinValue = (0, unit_1.convertCToF)(minValue);
        finalMaxValue = (0, unit_1.convertCToF)(maxValue);
    }
    else if (isPrecipitationMap && precipitationUnit === "in") {
        finalBins = (0, unit_1.convertmmToin)(bins);
        finalMinValue = (0, unit_1.convertmmToin)(minValue);
        finalMaxValue = (0, unit_1.convertmmToin)(maxValue);
    }
    const plusSign = isDiff && !isFrequent ? "+" : "";
    const prevBin = finalBins[index - 1];
    const curBin = finalBins[index];
    if (index > bins.length) {
        return [];
    }
    if (index === 0) {
        if (finalMinValue === 0 && finalMinValue === finalBins[index] - 1 && !isDiff) {
            return [finalMinValue.toString()];
        }
        else if (!isDiff) {
            return [finalMinValue.toString(), parseFloat((curBin - step).toFixed(1)).toString()];
        }
        else {
            return [curBin > 0 ? `< ${plusSign.concat(curBin.toString())}` : `< ${curBin}`];
        }
    }
    if (!isDiff) {
        const firstBin = prevBin.toString();
        let secondBin = "";
        if (index === finalBins.length) {
            secondBin = finalMaxValue.toString();
        }
        else {
            secondBin = parseFloat((curBin - step).toFixed(1)).toString();
        }
        return [firstBin, secondBin];
    }
    else {
        if (index === finalBins.length) {
            return [
                prevBin - step > 0
                    ? `> ${plusSign.concat(parseFloat((prevBin - step).toFixed(1)).toString())}`
                    : `> ${parseFloat((prevBin - step).toFixed(1)).toString()}`,
            ];
        }
        else {
            if (prevBin === curBin - step) {
                return [prevBin > 0 ? plusSign.concat(prevBin.toString()) : prevBin.toString()];
            }
            else {
                return [
                    prevBin > 0 ? plusSign.concat(prevBin.toString()) : prevBin.toString(),
                    curBin - step > 0
                        ? plusSign.concat(parseFloat((curBin - step).toFixed(1)).toString())
                        : parseFloat((curBin - step).toFixed(1)).toString(),
                ];
            }
        }
    }
}
exports.getBinLabel = getBinLabel;
const getBinLabelArray = (bins, index, minValue, maxValue, step) => {
    if (index === 0) {
        return [minValue, parseFloat((bins[index] - step).toFixed(1))];
    }
    return [
        bins[index - 1],
        index === bins.length ? maxValue : parseFloat((bins[index] - step).toFixed(1)),
    ];
};
exports.getBinLabelArray = getBinLabelArray;
